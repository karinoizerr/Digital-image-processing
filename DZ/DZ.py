import numpy as np
import cv2

cap = cv2.VideoCapture('BIRDbetter.mp4')                          # Захват видеофайла

# Словарь - параметры для метода нахождения углов Ши-Томаси
feature_params = dict( maxCorners = 100,                        # Максимальное количество найденных углов.
                       qualityLevel = 0.01,                     # Характеризует минимально допустимое качество угла. Умножается на показатель качества самого "лучшего" угла.
                       minDistance = 1,                         # Минимально возможное евклидово расстояние между возвращаемыми углами.
                       blockSize = 7 )                          # Размер среднего блока для вычисления производной ковариационной матрицы по каждому соседству пикселей.

# Словарь - параметры для вычисления оптического потока методом Лукаса-Канаде.
lk_params = dict( winSize  = (15,15),                           # Размер окна поиска на каждом уровне
                  maxLevel = 2,                                 # Номер максимального уровня пирамиды
                  criteria = (cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 0.03)) # Критерий остановки итераций алгоритма. Остановить, если достигнута точность 0.03 или после 10 итераций.

# Создание случайного набора цветов
color = np.random.randint(0,255,(100,3))                        # Диапазон случайной величины 0 - 255. Возвращается матрица цветов размерами 100x3.
# Берётся первый кадр и находятся углы
ret, old_frame = cap.read()                                     # Возвращет true в ret, если кадр читается правильно. old_frame содержит текущий кадр
old_gray = cv2.cvtColor(old_frame, cv2.COLOR_BGR2GRAY)          # Преобразует изображение из цветового пространства BGR в полутоновое.

p0 = cv2.goodFeaturesToTrack(old_gray, mask = None, **feature_params) # Функция нахождения N самых сильных углов на изображении методом Ши-Томази. Передаётся кадр old_gray, параметры из feature_params.
print(p0)                                                                   # Возвращает массив из пар-координатов углов (2D точек).
# Вывод первого кадра
cv2.imshow('frame', old_frame)                                  # Демоснтрация frame
cv2.waitKey(30) & 0xff
while True:                                                     # Цикл для запуска видео по нажатию клавиши
    k = cv2.waitKey(30) & 0xff                                  # k - ASCII код клавиши
    if k == 27:                                                 # Запуск видео - нажатие ESC
        break

count = 0                                                       # Счётчик обработанных кадров
cadr = 50                                                       # Количество начальных кадров, по которым определяется область объекта.
# Бесконечный цикл считывания кадров видео
while(1):
    ret,frame = cap.read()                                      # Считывание кадра. Возвращет true в ret, если кадр читается правильно. frame содержит текущий кадр
    if not ret:                                                 # выход из цикла, если не удалось считать кадр
        break
    frame_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)        # Преобразует кадр из цветового пространства BGR в полутоновое.
    # Вычисление оптического потока
    p1, st, err = cv2.calcOpticalFlowPyrLK(old_gray, frame_gray, p0, None, **lk_params)  # Вычисляет оптический поток объектов p0 (входной вектор 2D точек) на основе первого кадра old_gray и текущего кадра frame_gray
    print(p1)                                                                                         # с параметрами из lk_params.
                                                                                         # p1 - выходной вектор 2D точек, содержащий рассчитанные новые позиции входных объектов в текущем кадре.
                                                                                         # st - вектор состояний для каждой 2D точки. 1 - если оптический поток найден для точки. 0 - если не найден.
    if count <= cadr:                                           # Обработка первых кадров
        L = p1 - p0                                             # Расстояние, на которое перемещается точка с предыдущего кадра.
        move = []
        print('это эль', L)#ВЫВОЖУ ЭЛЬ                                               # Создание пустого списка движущихся точек.
        for i in range(len(L)):                                 # Цикл для заполнения списка точками, переместившимися по сравнению с предыдущем кадром.
            if (abs(L[i][0][0]) >= 0.01) or (abs(L[i][0][1] >= 0.01)): # Если точка переметсилась на пиксель по любому направлению.
                move.append(p1[i][0])                           # Присоединеие точки к списку.
                    
        move = np.array(move)                                   # Создание массива из списка.
        new_center = np.median(move, axis=0)                    # Рассчёт нового центра прямоугольной области объекта, как медиана движущихся точек.
        print(move)
        max_x = move[0][0]                                      # Нахождение X-координаты самой отдалённой точки от (0;0)
        for i in range(len(move)):
            if move[i][0] > max_x:
                max_x = move[i][0]
        max_y = move[0][1]                                      # Нахождение Y-координаты самой отдалённой точки от (0;0)
        for i in range(len(move)):
            if move[i][1] > max_y:
                max_y = move[i][1]
        min_x = move[0][0]                                      # Нахождение X-координаты самой приближённой точки к (0;0)
        for i in range(len(move)):
            if move[i][0] < min_x:
                min_x = move[i][0]
        min_y = move[0][1]                                      # Нахождение Y-координаты самой приближённой точки к (0;0)
        for i in range(len(move)):
            if move[i][1] < min_y:
                min_y = move[i][1]

        # Расчёт координат нижнего и верхнего углов прямоугольной области с объектом
        new_up = (new_center + (max_x, max_y) - new_center).reshape(-1)
        new_down = (new_center - new_center + (min_x, min_y)).reshape(-1)

        # Найденные отклоенния от центра
        new_x = max_x - new_center[0]
        new_y = max_y - new_center[1]

        # Прорисовка движущихся точек на кадре.
        for i,new in enumerate(move):
            a,b = new.ravel()
            frame = cv2.circle(frame,(a,b),5,color[i].tolist(),-1)      # Рисование точки

    if count > cadr:                                                    # Обработка последующих кадров
        good_new = p1[st==1]                                            # Дальшнейшая обработка точек, для которых найден оптический поток.
        new_center = np.mean(good_new, axis=0)                        # Рассчёт нового центра прямоугольной области объекта, как медиана точек.

        # Расчёт координат нижнего и верхнего углов прямоугольной области с объектом
        new_up = (new_center + (new_x, new_y)).reshape(-1)
        new_down = (new_center - (new_x, new_y)).reshape(-1)

        # Прорисовка точек на кадре.
        for i,new in enumerate(good_new):
            a,b = new.ravel()
            frame = cv2.circle(frame,(a,b),5,color[i].tolist(),-1)      # Рисование точки

    # Приведение размерности координат прямоугольной области с объектом для передачи их в функцию отрисовки прямоугольника
    nd = new_down.astype(np.integer).reshape(-1)
    nu = new_up.astype(np.integer).reshape(-1)

    if frame is not None:
        frame = cv2.rectangle(frame, tuple(nd), tuple(nu), (255, 0, 255), 4)   # Прорисовка прямоугольной области объекта
        cv2.imshow('frame',frame)                                              # Демоснтрация кадра
    k = cv2.waitKey(30) & 0xff                                                 # Задержка изорбражения 30 милисекунд.  В k возвращается нажатая клавиша клавиша.
    if k == 27:                                                                # Выход по нажатию  ESC
        break
    # Старый кадр теперь ссылается на текущий кадр
    old_gray = frame_gray.copy()
    # Для первых кадров в цикле точки для последующего кадра берутся из move
    if count <= cadr:
        p0 = move.reshape(-1,1,2)
    # Для последующих кадров в цикле точки для последующего кадра берутся из good_new
    if count > cadr:
        p0 = good_new.reshape(-1,1,2)

    count += 1                                                                 # Инкрементация счётчика
# Особождение ресурсов
cv2.destroyAllWindows()
cap.release()



